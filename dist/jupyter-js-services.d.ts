// Generated by dts-bundle v0.3.0

declare module 'jupyter-js-services' {
    import { Kernel } from '__jupyter-js-services/kernel';
    import { NotebookSession } from '__jupyter-js-services/session';
    export * from "__jupyter-js-services/kernel";
    export * from "__jupyter-js-services/session";
    var _default: {
        Kernel: typeof Kernel;
        NotebookSession: typeof NotebookSession;
    };
    export default _default;
}

declare module '__jupyter-js-services/kernel' {
    import ISignal = phosphor.core.ISignal;
    import IDisposable = phosphor.utility.IDisposable;
    /**
        * Kernel message header content.
        */
    export interface IKernelMsgHeader {
            username: string;
            version: string;
            session: string;
            msgId: string;
            msgType: string;
    }
    /**
        * Kernel message specification.
        */
    export interface IKernelMsg {
            header: IKernelMsgHeader;
            metadata: any;
            content: any;
            parentHeader: {} | IKernelMsgHeader;
            msgId?: string;
            msgType?: string;
            channel?: string;
            buffers?: string[] | ArrayBuffer[];
    }
    /**
        * Settings for a kernel execute command.
        */
    export interface IKernelExecute {
            silent?: boolean;
            user_expressions?: any;
            allow_stdin?: boolean;
            store_history?: boolean;
    }
    /**
        * Kernel identification specification.
        */
    export interface IKernelId {
            id: string;
            name: string;
    }
    /**
        * Kernel information specification.
        * http://ipython.org/ipython-doc/dev/development/messaging.html#kernel-info
        */
    export interface IKernelInfo {
            protocol_version: string;
            implementation: string;
            implementation_version: string;
            language_info: IKernelLanguageInfo;
            banner: string;
            help_links: {
                    [key: string]: string;
            };
    }
    /**
        * Kernel language information specification.
        */
    export interface IKernelLanguageInfo {
            name: string;
            version: string;
            mimetype: string;
            file_extension: string;
            pygments_lexer: string;
            codemirror_mode: string | {};
            nbconverter_exporter: string;
    }
    /**
        * Object providing a Future interface for message callbacks.
        *
        * Only one callback can be registered per type.
        * If `autoDispose` is set, the future will self-dispose after `isDone` is
        * set and the registered `onDone` handler is called.
        *
        * The Future is considered done when a `reply` message and a
        * an `idle` iopub status message have been received.
        */
    export interface IKernelFuture extends IDisposable {
            /**
                * The autoDispose behavior of the future.
                *
                * If True, it will self-dispose() after onDone() is called.
                */
            autoDispose: boolean;
            /**
                * Set when the message is done.
                */
            isDone: boolean;
            /**
                * Register a reply handler. Returns `this`.
                */
            onReply(cb: (msg: IKernelMsg) => void): IKernelFuture;
            /**
                * Register an output handler. Returns `this`.
                */
            onOutput(cb: (msg: IKernelMsg) => void): IKernelFuture;
            /**
                * Register a done handler. Returns `this`.
                */
            onDone(cb: (msg: IKernelMsg) => void): IKernelFuture;
            /**
                * Register an input handler. Returns `this`.
                */
            onInput(cb: (msg: IKernelMsg) => void): IKernelFuture;
    }
    /**
        * A class to communicate with the Python kernel. This
        * should generally not be constructed directly, but be created
        * by the `Session` object. Once created, this object should be
        * used to communicate with the kernel.
        */
    export class Kernel {
            /**
                * A signal emitted when the kernel changes state.
                */
            statusChanged: ISignal<string>;
            /**
                * GET /api/kernels
                *
                * Get the list of running kernels.
                */
            static list(baseUrl: string): Promise<IKernelId[]>;
            /**
                * Construct a new kernel.
                */
            constructor(baseUrl: string, wsUrl: string);
            /**
                * Set the name of the kernel.
                */
            name: string;
            /**
                * Check whether there is a connection to the kernel. This
                * function only returns true if websocket has been
                * created and has a state of WebSocket.OPEN.
                */
            isConnected: boolean;
            /**
                * Check whether the connection to the kernel has been completely
                * severed. This function only returns true if the websocket is null.
                */
            isFullyDisconnected: boolean;
            /**
                * Get the Info Reply Message from the kernel.
                */
            infoReply: IKernelInfo;
            /**
                * Get the current status of the kernel.
                */
            status: string;
            /**
                * Set the current id of the kernel.
                */
            id: string;
            /**
                * Get the full websocket url.
                */
            wsUrl: string;
            /**
                * GET /api/kernels/[:kernel_id]
                *
                * Get information about the kernel.
                */
            getInfo(): Promise<IKernelId>;
            /**
                * POST /api/kernels/[:kernel_id]/interrupt
                *
                * Interrupt the kernel.
                */
            interrupt(): Promise<void>;
            /**
                * POST /api/kernels/[:kernel_id]/restart
                *
                * Restart the kernel.
                */
            restart(): Promise<IKernelId>;
            /**
                * POST /api/kernels/[:kernel_id]
                *
                * Start a kernel.  Note: if using a session, Session.start()
                * should be used instead.
                */
            start(id?: IKernelId): Promise<IKernelId>;
            /**
                * DELETE /api/kernels/[:kernel_id]
                *
                * Shut down a kernel. Note: if useing a session, Session.shutdown()
                * should be used instead.
                */
            shutdown(): Promise<void>;
            /**
                * Connect to the server-side the kernel.
                *
                * This should only be called directly by a session.
                */
            connect(id?: IKernelId): void;
            /**
                * Disconnect the kernel.
                */
            disconnect(): void;
            /**
                 * Reconnect to a disconnected kernel. This is not actually a
                 * standard HTTP request, but useful function nonetheless for
                 * reconnecting to the kernel if the connection is somehow lost.
                 */
            reconnect(): void;
            /**
                * Send a message on the kernel's shell channel.
                */
            sendShellMessage(msg_type: string, content: any, metadata?: {}, buffers?: string[]): IKernelFuture;
            /**
                * Get kernel info.
                *
                * Returns a KernelFuture that will resolve to a `kernel_info_reply` message documented
                * [here](http://ipython.org/ipython-doc/dev/development/messaging.html#kernel-info)
                */
            kernelInfo(): IKernelFuture;
            /**
                * Get info on an object.
                *
                * Returns a KernelFuture that will resolve to a `inspect_reply` message documented
                * [here](http://ipython.org/ipython-doc/dev/development/messaging.html#object-information)
                */
            inspect(code: string, cursor_pos: number): IKernelFuture;
            /**
                * Execute given code into kernel, returning a KernelFuture.
                *
                * @example
                *
                * The options object should contain the options for the execute
                * call. Its default values are:
                *
                *      options = {
                *        silent : true,
                *        user_expressions : {},
                *        allow_stdin : false,
                                store_history: false
                *      }
                *
                */
            execute(code: string, options?: IKernelExecute): IKernelFuture;
            /**
                * Request a code completion from the kernel.
                *
                * Returns a KernelFuture with will resolve to a `complete_reply` documented
                * [here](http://ipython.org/ipython-doc/dev/development/messaging.html#complete)
                */
            complete(code: string, cursor_pos: number): IKernelFuture;
            /**
                * Send an input reply message to the kernel.
                *
                * TODO: how to handle this?  Right now called by
                * ./static/notebook/js/outputarea.js:827:
                * this.events.trigger('send_input_reply.Kernel', value);
                *
                * which has no reference to the session or the kernel
                */
            sendInputReply(input: any): string;
    }
    /**
        * Validate an object as being of IKernelID type
        */
    export function validateKernelId(info: IKernelId): void;
}

declare module '__jupyter-js-services/session' {
    import ISignal = phosphor.core.ISignal;
    import { IKernelId, Kernel } from '__jupyter-js-services/kernel';
    /**
        * Notebook Identification specification.
        */
    export interface INotebookId {
            path: string;
    }
    /**
        * Session Identification specification.
        */
    export interface ISessionId {
            id: string;
            notebook: INotebookId;
            kernel: IKernelId;
    }
    /**
        * Session initialization options.
        */
    export interface ISessionOptions {
            notebookPath: string;
            kernelName: string;
            baseUrl: string;
            wsUrl: string;
    }
    /**
        * Session object for accessing the session REST api. The session
        * should be used to start kernels and then shut them down -- for
        * all other operations, the kernel object should be used.
        **/
    export class NotebookSession {
            /**
                * A signal emitted when the session changes state.
                */
            statusChanged: ISignal<string>;
            /**
                * GET /api/sessions
                *
                * Get a list of the current sessions.
                */
            static list(baseUrl: string): Promise<ISessionId[]>;
            /**
                * Construct a new session.
                */
            constructor(options: ISessionOptions);
            /**
                * Get the session kernel object.
             */
            kernel: Kernel;
            /**
                * POST /api/sessions
                *
                * Start a new session. This function can only be successfully executed once.
                */
            start(): Promise<ISessionId>;
            /**
                * GET /api/sessions/[:session_id]
                *
                * Get information about a session.
                */
            getInfo(): Promise<ISessionId>;
            /**
                * DELETE /api/sessions/[:session_id]
                *
                * Kill the kernel and shutdown the session.
                */
            delete(): Promise<void>;
            /**
                * Restart the session by deleting it and then starting it fresh.
                */
            restart(options?: ISessionOptions): Promise<void>;
            /**
                * Rename the notebook.
                */
            renameNotebook(path: string): Promise<ISessionId>;
    }
}

